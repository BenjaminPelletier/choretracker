{% extends "base.html" %}

{% block title %}{{ entry.title }} {{ entry.type.value }} - Chore Tracker{% endblock %}

{% block content %}
<h1 id="title-type">
    <span id="title-text">{{ entry.title }}</span>
    <span id="type-text">{{ entry.type.value }}</span>
    {% if can_edit %}
    <button type="button" id="edit-title-type" class="icon-button"><img src="{{ url_for('static', path='pen.svg') }}" alt="Edit" class="icon"></button>
    {% if can_delete %}
    <form method="post" action="{{ url_for('delete_calendar_entry', entry_id=entry.id) }}" style="display:inline" onsubmit="return confirm('Are you sure you want to delete this entry?');">
        <input type="hidden" name="csrf_token" value="{{ request.session['csrf_token'] }}">
        <button type="submit" class="icon-button"><img src="{{ url_for('static', path='trash.svg') }}" alt="Delete" class="icon"></button>
    </form>
    {% endif %}
    {% endif %}
</h1>
<p class="time-range">{{ time_range_summary(entry_start, entry_end) }}</p>
{% if prev_entry %}
<p class="time-range">Previous: <a href="{{ url_for('view_calendar_entry', entry_id=prev_entry.id) }}">{{ time_range_summary(prev_start, prev_end) }}</a></p>
{% endif %}
{% if next_entry %}
<p class="time-range">Next: <a href="{{ url_for('view_calendar_entry', entry_id=next_entry.id) }}">{{ time_range_summary(next_start, next_end) }}</a></p>
{% endif %}
<div class="description" id="description-container">
    <div id="description-text">{{ entry.description|markdown|safe }}</div>
    {% if can_edit %}
    <button type="button" id="edit-description" class="icon-button" data-desc="{{ entry.description|b64encode }}"><img src="{{ url_for('static', path='pen.svg') }}" alt="Edit" class="icon"></button>
    {% endif %}
</div>
<dl>
    <dt>Managers: <span id="entry-managers-container" data-managers='{{ entry.managers|tojson }}'>
        {% for user in entry.managers %}
        <img src="{{ url_for('profile_picture', username=user) }}" alt="{{ user }}" class="profile-icon" />
        {% endfor %}
        {% if can_edit %}
        <button type="button" id="edit-managers" class="icon-button"><img src="{{ url_for('static', path='pen.svg') }}" alt="Edit" class="icon"></button>
        {% endif %}
    </span></dt>
    {% if entry.none_before %}
    <dt>None before: <span id="none-before-text">{{ entry.none_before|format_datetime(include_day=True) }}</span></dt>
    {% endif %}
    <dt>Responsible: <span id="entry-responsible-container" data-responsible='{{ entry.responsible|tojson }}'>
        {% for user in entry.responsible %}
        <img src="{{ url_for('profile_picture', username=user) }}" alt="{{ user }}" class="profile-icon" />
        {% endfor %}
        {% if can_edit %}
        <button type="button" id="edit-responsible" class="icon-button"><img src="{{ url_for('static', path='pen.svg') }}" alt="Edit" class="icon"></button>
        {% endif %}
    </span></dt>
    <dt>Recurrences{% if can_edit %} <button type="button" id="add-recurrence" class="icon-button"><img src="{{ url_for('static', path='plus.svg') }}" alt="Add recurrence" class="icon"></button>{% endif %}</dt>
    <dd id="recurrence-container">
        {% if entry.recurrences %}
        <ul id="recurrence-list">
            {% for rec in entry.recurrences %}
            <li class="recurrence-item" data-rid="{{ rec.id }}" data-type="{{ rec.type.value }}" data-responsible='{{ rec.responsible|tojson }}' data-first-start="{{ rec.first_start.strftime('%Y-%m-%dT%H:%M') }}" data-duration-seconds="{{ rec.duration_seconds }}">
                <span class="recurrence-text">{{ rec.type.value }}</span>
                {% for user in rec.responsible %}
                <img src="{{ url_for('profile_picture', username=user) }}" alt="{{ user }}" class="profile-icon" />
                {% endfor %}
                {% if can_edit %}
                <button type="button" class="icon-button edit-recurrence"><img src="{{ url_for('static', path='pen.svg') }}" alt="Edit" class="icon"></button>
                <button type="button" class="icon-button delete-recurrence"><img src="{{ url_for('static', path='trash.svg') }}" alt="Delete" class="icon"></button>
                {% endif %}
            </li>
            {% endfor %}
        </ul>
        {% else %}
        None
        {% endif %}
    </dd>
    {% if entry.recurrences %}
        <dt id="none-after-row" data-current="{{ entry.none_after.strftime('%Y-%m-%dT%H:%M') if entry.none_after else '' }}">
            {% if entry.none_after %}
            None after: <span id="none-after-text">{{ entry.none_after|format_datetime(include_day=True) }}</span>
            {% else %}
            Repeats forever
            {% endif %}
            {% if can_edit %}
            <button type="button" id="edit-none-after" class="icon-button"><img src="{{ url_for('static', path='pen.svg') }}" alt="Edit" class="icon"></button>
            {% endif %}
        </dt>
    {% endif %}
</dl>
{% if past_instances or upcoming_instances %}
<h2>Instances</h2>
    {% if past_instances %}
    <h3>Past <a href="{{ url_for('view_calendar_entry', entry_id=entry.id) }}?past_entries={{ past_entries + 5 }}&upcoming_entries={{ upcoming_entries }}" class="icon-button"><img src="{{ url_for('static', path='plus.svg') }}" alt="Show more past instances" class="icon"></a></h3>
    <ul class="time-list">
        {% for period, completion, can_remove, is_skipped, responsible, has_note in past_instances %}
        <li>
            <a href="{{ url_for('view_time_period', entry_id=entry.id, recurrence_id=period.recurrence_id, iindex=period.instance_index) }}">{{ time_range_summary(period.start, period.end) }}</a>{% if has_note %}<span class="note-marker">*</span>{% endif %}
            {% for user in responsible %}
            <img src="{{ url_for('profile_picture', username=user) }}" alt="{{ user }}" class="profile-icon" />
            {% endfor %}
            {% if completion %}
            <img src="{{ url_for('static', path='checkbox-checked.svg') }}" class="checkbox-icon" data-entry="{{ entry.id }}" data-rid="{{ completion.recurrence_id }}" data-iindex="{{ completion.instance_index }}" {% if can_remove %}data-action="remove"{% endif %} />
            <img src="{{ url_for('profile_picture', username=completion.completed_by) }}" alt="{{ completion.completed_by }}" class="profile-icon" />
            {{ completion.completed_at|format_completion_time(period.end) }}
            {% endif %}
            {% if is_skipped %} (skipped){% endif %}
        </li>
        {% endfor %}
    </ul>
    {% endif %}
    {% if upcoming_instances %}
    <h3>Upcoming <a href="{{ url_for('view_calendar_entry', entry_id=entry.id) }}?past_entries={{ past_entries }}&upcoming_entries={{ upcoming_entries + 5 }}" class="icon-button"><img src="{{ url_for('static', path='plus.svg') }}" alt="Show more upcoming instances" class="icon"></a></h3>
    <ul class="time-list">
        {% for period, completion, can_remove, is_skipped, responsible, has_note in upcoming_instances %}
        <li>
            <a href="{{ url_for('view_time_period', entry_id=entry.id, recurrence_id=period.recurrence_id, iindex=period.instance_index) }}">{{ time_range_summary(period.start, period.end) }}</a>{% if has_note %}<span class="note-marker">*</span>{% endif %}
            {% for user in responsible %}
            <img src="{{ url_for('profile_picture', username=user) }}" alt="{{ user }}" class="profile-icon" />
            {% endfor %}
            {% if is_skipped %} (skipped){% endif %}
        </li>
        {% endfor %}
    </ul>
    {% endif %}
{% endif %}
<script>
document.querySelectorAll('.checkbox-icon[data-action="remove"]').forEach(el => {
    el.addEventListener('click', async () => {
        const entry = el.dataset.entry;
        const r = parseInt(el.dataset.rid);
        const i = parseInt(el.dataset.iindex);
        await fetch(`/calendar/${entry}/completion/remove`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            credentials: 'same-origin',
            body: JSON.stringify({recurrence_id: r, instance_index: i})
        });
        location.reload();
    });
});
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const entryId = {{ entry.id }};
    const diskUrl = "{{ url_for('static', path='disk.svg') }}";
    const xUrl = "{{ url_for('static', path='x.svg') }}";
    const trashUrl = "{{ url_for('static', path='trash.svg') }}";
    const plusUrl = "{{ url_for('static', path='plus.svg') }}";
    const profileUrlTemplate = "{{ url_for('profile_picture', username='__user__') }}";
    const allUsers = {{ all_users()|selectattr('username','ne','Viewer')|map(attribute='username')|list|tojson }};
    const recurrenceTypes = {{ RecurrenceType|map(attribute='value')|list|tojson }};
    const durationUrl = "{{ url_for('static', path='duration.svg') }}";
    const endTimeUrl = "{{ url_for('static', path='endtime.svg') }}";

    function makeBtn(url, alt) {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'icon-button';
        const img = document.createElement('img');
        img.src = url;
        img.alt = alt;
        img.className = 'icon';
        b.appendChild(img);
        return b;
    }

    

    const naEdit = document.getElementById('edit-none-after');
    if (naEdit) {
        naEdit.addEventListener('click', () => {
            const row = document.getElementById('none-after-row');
            const current = row.dataset.current;
            row.innerHTML = '';
            const label = document.createElement('span');
            label.textContent = 'Never after: ';
            const input = document.createElement('input');
            input.type = 'datetime-local';
            if (current) {
                input.value = current;
            } else {
                const now = new Date();
                const local = new Date(now.getTime() - now.getTimezoneOffset() * 60000)
                    .toISOString()
                    .slice(0, 16);
                input.value = local;
            }
            input.className = 'inline-input';
            const clearBtn = makeBtn(trashUrl, 'Clear');
            const save = makeBtn(diskUrl, 'Save');
            const cancel = makeBtn(xUrl, 'Cancel');
            row.appendChild(label);
            row.appendChild(input);
            row.appendChild(clearBtn);
            row.appendChild(save);
            row.appendChild(cancel);
            clearBtn.addEventListener('click', () => { input.value = ''; });
            save.addEventListener('click', async () => {
                await fetch(`/calendar/${entryId}/update`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'same-origin',
                    body: JSON.stringify({ none_after: input.value })
                });
                location.reload();
            });
            cancel.addEventListener('click', () => location.reload());
        });
    }

    const mgrEdit = document.getElementById('edit-managers');
    if (mgrEdit) {
        mgrEdit.addEventListener('click', () => {
            const container = document.getElementById('entry-managers-container');
            const managers = JSON.parse(container.dataset.managers || '[]');
            container.innerHTML = '';
            const mgrContainer = document.createElement('span');

            function addMgr(user) {
                const wrapper = document.createElement('span');
                const img = document.createElement('img');
                img.src = profileUrlTemplate.replace('__user__', encodeURIComponent(user));
                img.alt = user;
                img.className = 'profile-icon';
                const rm = makeBtn(trashUrl, 'Remove');
                rm.addEventListener('click', () => {
                    wrapper.remove();
                    const idx = managers.indexOf(user);
                    if (idx >= 0) managers.splice(idx, 1);
                    refreshDropdown();
                });
                wrapper.appendChild(img);
                wrapper.appendChild(rm);
                mgrContainer.appendChild(wrapper);
            }

            const addWrap = document.createElement('span');
            addWrap.className = 'responsible-selector';
            const addBtn = makeBtn(plusUrl, 'Add user');
            const dropdown = document.createElement('div');
            dropdown.className = 'dropdown';
            dropdown.style.display = 'none';

            function refreshDropdown() {
                dropdown.innerHTML = '';
                allUsers.filter(u => !managers.includes(u)).forEach(u => {
                    const a = document.createElement('a');
                    a.href = '#';
                    a.textContent = u;
                    a.addEventListener('click', e => {
                        e.preventDefault();
                        managers.push(u);
                        addMgr(u);
                        dropdown.style.display = 'none';
                        refreshDropdown();
                    });
                    dropdown.appendChild(a);
                });
            }

            addBtn.addEventListener('click', () => {
                dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
            });

            addWrap.appendChild(addBtn);
            addWrap.appendChild(dropdown);

            managers.forEach(u => addMgr(u));
            refreshDropdown();

            const save = makeBtn(diskUrl, 'Save');
            const cancel = makeBtn(xUrl, 'Cancel');

            container.appendChild(mgrContainer);
            container.appendChild(addWrap);
            container.appendChild(save);
            container.appendChild(cancel);

            save.addEventListener('click', async () => {
                await fetch(`/calendar/${entryId}/update`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'same-origin',
                    body: JSON.stringify({managers: managers})
                });
                location.reload();
            });
            cancel.addEventListener('click', () => location.reload());
        });
    }

    const respEdit = document.getElementById('edit-responsible');
    if (respEdit) {
        respEdit.addEventListener('click', () => {
            const container = document.getElementById('entry-responsible-container');
            const responsible = JSON.parse(container.dataset.responsible || '[]');
            container.innerHTML = '';
            const respContainer = document.createElement('span');

            function addResp(user) {
                const wrapper = document.createElement('span');
                const img = document.createElement('img');
                img.src = profileUrlTemplate.replace('__user__', encodeURIComponent(user));
                img.alt = user;
                img.className = 'profile-icon';
                const rm = makeBtn(trashUrl, 'Remove');
                rm.addEventListener('click', () => {
                    wrapper.remove();
                    const idx = responsible.indexOf(user);
                    if (idx >= 0) responsible.splice(idx, 1);
                    refreshDropdown();
                });
                wrapper.appendChild(img);
                wrapper.appendChild(rm);
                respContainer.appendChild(wrapper);
            }

            const addWrap = document.createElement('span');
            addWrap.className = 'responsible-selector';
            const addBtn = makeBtn(plusUrl, 'Add user');
            const dropdown = document.createElement('div');
            dropdown.className = 'dropdown';
            dropdown.style.display = 'none';

            function refreshDropdown() {
                dropdown.innerHTML = '';
                allUsers.filter(u => !responsible.includes(u)).forEach(u => {
                    const a = document.createElement('a');
                    a.href = '#';
                    a.textContent = u;
                    a.addEventListener('click', e => {
                        e.preventDefault();
                        responsible.push(u);
                        addResp(u);
                        dropdown.style.display = 'none';
                        refreshDropdown();
                    });
                    dropdown.appendChild(a);
                });
            }

            addBtn.addEventListener('click', () => {
                dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
            });

            addWrap.appendChild(addBtn);
            addWrap.appendChild(dropdown);

            responsible.forEach(u => addResp(u));
            refreshDropdown();

            const save = makeBtn(diskUrl, 'Save');
            const cancel = makeBtn(xUrl, 'Cancel');

            container.appendChild(respContainer);
            container.appendChild(addWrap);
            container.appendChild(save);
            container.appendChild(cancel);

            save.addEventListener('click', async () => {
                await fetch(`/calendar/${entryId}/update`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'same-origin',
                    body: JSON.stringify({responsible: responsible})
                });
                location.reload();
            });
            cancel.addEventListener('click', () => location.reload());
        });
    }

    const recContainer = document.getElementById('recurrence-container');
    let recList = document.getElementById('recurrence-list');

    function setupRecurrenceEditor(li, rid, originalType, originalResp, originalFirstStart, originalDuration, isNew) {
        if (isNew && addRecurrence) {
            addRecurrence.style.display = 'none';
        }
        li.innerHTML = '';

        const typeSelect = document.createElement('select');
        typeSelect.className = 'inline-input';
        recurrenceTypes.forEach(t => {
            const opt = document.createElement('option');
            opt.value = t;
            opt.textContent = t;
            if (t === originalType) opt.selected = true;
            typeSelect.appendChild(opt);
        });

        const startInput = document.createElement('input');
        startInput.type = 'datetime-local';
        startInput.className = 'inline-input';
        startInput.required = true;
        if (originalFirstStart) {
            startInput.value = originalFirstStart;
        } else {
            const now = new Date();
            if (now.getMinutes() > 0 || now.getSeconds() > 0 || now.getMilliseconds() > 0) {
                now.setHours(now.getHours() + 1);
            }
            now.setMinutes(0, 0, 0);
            const local = new Date(now.getTime() - now.getTimezoneOffset() * 60000)
                .toISOString()
                .slice(0, 16);
            startInput.value = local;
        }

        const durationWrap = document.createElement('span');
        durationWrap.className = 'duration-inputs';
        const toggleBtn = makeBtn(endTimeUrl, 'Use end time');
        const modeIcon = toggleBtn.querySelector('img');
        const durationFields = document.createElement('span');
        const daysInput = document.createElement('input');
        daysInput.type = 'number';
        daysInput.placeholder = 'Days';
        daysInput.min = '0';
        daysInput.className = 'inline-input';
        const hoursInput = document.createElement('input');
        hoursInput.type = 'number';
        hoursInput.placeholder = 'Hours';
        hoursInput.min = '0';
        hoursInput.className = 'inline-input';
        const minutesInput = document.createElement('input');
        minutesInput.type = 'number';
        minutesInput.placeholder = 'Minutes';
        minutesInput.min = '0';
        minutesInput.max = '59';
        minutesInput.className = 'inline-input';
        durationFields.appendChild(daysInput);
        durationFields.appendChild(hoursInput);
        durationFields.appendChild(minutesInput);
        const endInput = document.createElement('input');
        endInput.type = 'datetime-local';
        endInput.className = 'inline-input';
        endInput.style.display = 'none';
        endInput.disabled = true;
        durationWrap.appendChild(toggleBtn);
        durationWrap.appendChild(durationFields);
        durationWrap.appendChild(endInput);

        if (originalDuration) {
            const d = Math.floor(originalDuration / 86400);
            const h = Math.floor((originalDuration % 86400) / 3600);
            const m = Math.floor((originalDuration % 3600) / 60);
            if (d) daysInput.value = d;
            if (h) hoursInput.value = h;
            if (m) minutesInput.value = m;
        }

        let useEndTime = false;
        function computeDuration() {
            if (useEndTime) {
                const start = new Date(startInput.value);
                const end = new Date(endInput.value);
                return (end - start) / 1000;
            } else {
                const d = Number(daysInput.value) || 0;
                const h = Number(hoursInput.value) || 0;
                const m = Number(minutesInput.value) || 0;
                return d * 86400 + h * 3600 + m * 60;
            }
        }
        function validateDuration() {
            const total = computeDuration();
            const targets = useEndTime ? [endInput] : [daysInput, hoursInput, minutesInput];
            targets.forEach(inp => {
                if (total <= 0) {
                    inp.setCustomValidity('Duration must be greater than 0');
                } else {
                    inp.setCustomValidity('');
                }
            });
            return total > 0;
        }
        function updateEndFromInputs() {
            const start = new Date(startInput.value);
            const d = Number(daysInput.value) || 0;
            const h = Number(hoursInput.value) || 0;
            const m = Number(minutesInput.value) || 0;
            const end = new Date(start.getTime() + (d * 86400 + h * 3600 + m * 60) * 1000);
            const local = new Date(end.getTime() - end.getTimezoneOffset() * 60000)
                .toISOString()
                .slice(0, 16);
            endInput.value = local;
        }
        function updateInputsFromEnd() {
            const start = new Date(startInput.value);
            const end = new Date(endInput.value);
            let diff = Math.floor((end - start) / 1000);
            const d = Math.floor(diff / 86400);
            diff -= d * 86400;
            const h = Math.floor(diff / 3600);
            diff -= h * 3600;
            const m = Math.floor(diff / 60);
            daysInput.value = d || '';
            hoursInput.value = h || '';
            minutesInput.value = m || '';
        }

        toggleBtn.addEventListener('click', () => {
            useEndTime = !useEndTime;
            if (useEndTime) {
                modeIcon.src = durationUrl;
                modeIcon.alt = 'Use duration';
                durationFields.style.display = 'none';
                [daysInput, hoursInput, minutesInput].forEach(inp => {
                    inp.disabled = true;
                    inp.setCustomValidity('');
                });
                endInput.style.display = '';
                endInput.disabled = false;
                updateEndFromInputs();
            } else {
                modeIcon.src = endTimeUrl;
                modeIcon.alt = 'Use end time';
                durationFields.style.display = '';
                [daysInput, hoursInput, minutesInput].forEach(inp => {
                    inp.disabled = false;
                });
                endInput.style.display = 'none';
                endInput.disabled = true;
                endInput.setCustomValidity('');
                updateInputsFromEnd();
            }
            validateDuration();
        });

        [daysInput, hoursInput, minutesInput].forEach(inp =>
            inp.addEventListener('input', () => { if (!useEndTime) validateDuration(); })
        );
        endInput.addEventListener('input', () => { if (useEndTime) validateDuration(); });
        startInput.addEventListener('input', () => {
            if (useEndTime) {
                validateDuration();
            } else {
                updateEndFromInputs();
            }
        });

        const respContainer = document.createElement('span');
        const responsible = [...originalResp];

        function addResp(user) {
            const wrapper = document.createElement('span');
            const img = document.createElement('img');
            img.src = profileUrlTemplate.replace('__user__', encodeURIComponent(user));
            img.alt = user;
            img.className = 'profile-icon';
            const rm = makeBtn(trashUrl, 'Remove');
            rm.addEventListener('click', () => {
                wrapper.remove();
                const idx = responsible.indexOf(user);
                if (idx >= 0) responsible.splice(idx, 1);
                refreshDropdown();
            });
            wrapper.appendChild(img);
            wrapper.appendChild(rm);
            respContainer.appendChild(wrapper);
        }

        const addWrap = document.createElement('span');
        addWrap.className = 'responsible-selector';
        const addBtn = makeBtn(plusUrl, 'Add user');
        const dropdown = document.createElement('div');
        dropdown.className = 'dropdown';
        dropdown.style.display = 'none';

        function refreshDropdown() {
            dropdown.innerHTML = '';
            allUsers.filter(u => !responsible.includes(u)).forEach(u => {
                const a = document.createElement('a');
                a.href = '#';
                a.textContent = u;
                a.addEventListener('click', e => {
                    e.preventDefault();
                    responsible.push(u);
                    addResp(u);
                    dropdown.style.display = 'none';
                    refreshDropdown();
                });
                dropdown.appendChild(a);
            });
        }

        addBtn.addEventListener('click', () => {
            dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
        });

        addWrap.appendChild(addBtn);
        addWrap.appendChild(dropdown);

        originalResp.forEach(u => addResp(u));
        refreshDropdown();

        const save = makeBtn(diskUrl, 'Save');
        const cancel = makeBtn(xUrl, 'Cancel');

        li.appendChild(typeSelect);
        li.appendChild(startInput);
        li.appendChild(durationWrap);
        li.appendChild(respContainer);
        li.appendChild(addWrap);
        li.appendChild(save);
        li.appendChild(cancel);

        save.addEventListener('click', async () => {
            if (!validateDuration()) {
                return;
            }
            const url = isNew ? `/calendar/${entryId}/recurrence/add` : `/calendar/${entryId}/recurrence/update`;
            const payload = {
                type: typeSelect.value,
                first_start: startInput.value,
                duration_seconds: computeDuration(),
                responsible: responsible
            };
            if (!isNew) {
                payload.recurrence_id = rid;
            }
            const resp = await fetch(url, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                credentials: 'same-origin',
                body: JSON.stringify(payload)
            });
            if (resp.ok) {
                const data = await resp.json();
                if (data.redirect) {
                    window.location = data.redirect;
                } else {
                    location.reload();
                }
            } else {
                alert(`Failed to ${isNew ? 'add' : 'update'} recurrence`);
            }
        });
        cancel.addEventListener('click', () => {
            if (isNew) {
                li.remove();
                if (!recList || recList.children.length === 0) {
                    recContainer.textContent = 'None';
                }
                if (addRecurrence) {
                    addRecurrence.style.display = '';
                }
            } else {
                location.reload();
            }
        });
    }

    document.querySelectorAll('.recurrence-item .edit-recurrence').forEach(btn => {
        btn.addEventListener('click', () => {
            const li = btn.closest('.recurrence-item');
            const rid = parseInt(li.dataset.rid);
            const originalType = li.dataset.type;
            const originalResp = JSON.parse(li.dataset.responsible || '[]');
            const originalFirstStart = li.dataset.firstStart;
            const originalDuration = parseInt(li.dataset.durationSeconds || '0');
            setupRecurrenceEditor(li, rid, originalType, originalResp, originalFirstStart, originalDuration, false);
        });
    });

    document.querySelectorAll('.recurrence-item .delete-recurrence').forEach(btn => {
        btn.addEventListener('click', async () => {
            const li = btn.closest('.recurrence-item');
            const rid = parseInt(li.dataset.rid);
            const resp = await fetch(`/calendar/${entryId}/recurrence/delete`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                credentials: 'same-origin',
                body: JSON.stringify({recurrence_id: rid})
            });
            if (resp.ok) {
                const data = await resp.json();
                if (data.redirect) {
                    window.location = data.redirect;
                } else {
                    location.reload();
                }
            } else {
                alert('Failed to delete recurrence');
            }
        });
    });

    const addRecurrence = document.getElementById('add-recurrence');
    if (addRecurrence) {
        addRecurrence.addEventListener('click', () => {
            if (!recList) {
                recList = document.createElement('ul');
                recList.id = 'recurrence-list';
                recContainer.innerHTML = '';
                recContainer.appendChild(recList);
            }
            const li = document.createElement('li');
            li.className = 'recurrence-item';
            recList.appendChild(li);
            setupRecurrenceEditor(li, -1, recurrenceTypes[0], [], null, null, true);
        });
    }

    const descEdit = document.getElementById('edit-description');
    if (descEdit) {
        descEdit.addEventListener('click', () => {
            const container = document.getElementById('description-container');
            const textarea = document.createElement('textarea');
            const raw = atob(descEdit.dataset.desc || '');
            textarea.value = raw;
            textarea.className = 'inline-input';
            const save = makeBtn(diskUrl, 'Save');
            const cancel = makeBtn(xUrl, 'Cancel');
            container.innerHTML = '';
            container.appendChild(textarea);
            container.appendChild(save);
            container.appendChild(cancel);
            save.addEventListener('click', async () => {
                const resp = await fetch(`/calendar/${entryId}/update`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'same-origin',
                    body: JSON.stringify({description: textarea.value})
                });
                const data = await resp.json();
                if (data.redirect) {
                    window.location = data.redirect;
                } else {
                    location.reload();
                }
            });
            cancel.addEventListener('click', () => location.reload());
        });
    }

    const ttEdit = document.getElementById('edit-title-type');
    if (ttEdit) {
        ttEdit.addEventListener('click', () => {
            const container = document.getElementById('title-type');
            const titleInput = document.createElement('input');
            titleInput.type = 'text';
            titleInput.value = {{ entry.title|tojson }};
            titleInput.className = 'inline-input';
            const typeSelect = document.createElement('select');
            typeSelect.className = 'inline-input';
            {% for t in CalendarEntryType %}
            const opt{{ loop.index0 }} = document.createElement('option');
            opt{{ loop.index0 }}.value = "{{ t.value }}";
            opt{{ loop.index0 }}.textContent = "{{ t.value }}";
            if ("{{ t.value }}" === "{{ entry.type.value }}") opt{{ loop.index0 }}.selected = true;
            typeSelect.appendChild(opt{{ loop.index0 }});
            {% endfor %}
            const save = makeBtn(diskUrl, 'Save');
            const cancel = makeBtn(xUrl, 'Cancel');
            container.innerHTML = '';
            container.appendChild(titleInput);
            container.appendChild(typeSelect);
            container.appendChild(save);
            container.appendChild(cancel);
            save.addEventListener('click', async () => {
                const resp = await fetch(`/calendar/${entryId}/update`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'same-origin',
                    body: JSON.stringify({title: titleInput.value, type: typeSelect.value})
                });
                const data = await resp.json();
                if (data.redirect) {
                    window.location = data.redirect;
                } else {
                    location.reload();
                }
            });
            cancel.addEventListener('click', () => location.reload());
        });
    }
});
</script>
{% endblock %}
